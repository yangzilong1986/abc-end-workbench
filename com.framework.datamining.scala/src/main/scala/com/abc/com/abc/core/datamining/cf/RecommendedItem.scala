package com.abc.com.abc.core.datamining.cf

import org.apache.log4j.{Level, Logger}
import org.apache.spark.rdd.RDD

/**
  * Created by admin on 2017/6/7.
  */
class RecommendedItem {
  /**
    *
    * @param items_similar
    * @param user_pref
    * @return
    */
  def Recommand(items_similar:RDD[ItemSimi],
                user_pref:RDD[ItemRef]
               ):(RDD[UserRecomm])={
    //1.准备数据
    val rdd_app1_R1=items_similar.map(f=>(f.itemId1,f.itemId2,f.similar))
    val user_prefer1=user_pref.map(f=>(f.userId,f.itemId,f.pref))
    //2.矩阵计算，i行与j列的join
    val rdd_app1_R2=rdd_app1_R1.map(f=>(f._1,(f._2,f._3))).join(user_prefer1.map(f=>(f._2,(f._1,f._3))))
    //3.矩阵计算，i行与j列元素相乘
    val rdd_app1_R3=rdd_app1_R2.map(f=>((f._2._2._1,f._2._1._1),f._2._2._2 * f._2._1._2.toDouble))
    //4.用户:元素累加求和
    val rdd_app1_R4=rdd_app1_R3.reduceByKey((x,y)=>x+y)
    //5.用户，对结果过滤已有的物品
    val rdd_app1_R5=rdd_app1_R4.leftOuterJoin(user_prefer1.map(f=>((f._1,f._2),1))).
      filter(f=>f._2._2.isEmpty).map(f=>(f._1._1,(f._1._2,f._2._1)))
    //在很多应用场景都需要对结果数据进行排序，Spark中有时也不例外。在Spark中存在两种对RDD进行排序的函数，
    // 分别是 sortBy和sortByKey函数。sortBy是对标准的RDD进行排序，它是从Spark 0.9.0之后才引入的（可以参见SPARK-1063）。
    // 而sortByKey函数是对PairRDD进行排序，也就是有Key和Value的RDD。
    val rdd_app1_R6=rdd_app1_R5.map(f=>(f._1,f._2._1,f._2._2)).sortBy(f=>(f._1,f._3))
    rdd_app1_R6.map(f=>UserRecomm(f._1,f._2,f._3))
  }

  /**
    *
    * @param items_similar
    * @param user_pref
    * @param r_number
    * @return
    */
  def Recommand(items_similar:RDD[ItemSimi],
                user_pref:RDD[ItemRef],
                r_number:Int
               ):(RDD[UserRecomm])={

    Logger.getRootLogger.setLevel(Level.WARN)
    //1.准备数据
    val rdd_app1_R1=items_similar.map(f=>(f.itemId1,f.itemId2,f.similar))
    val user_prefer1=user_pref.map(f=>(f.userId,f.itemId,f.pref))

    //2.矩阵计算，i行与j列的join
    val rdd_app1_R2=rdd_app1_R1.map(f=>(f._1,(f._2,f._3))).join(user_prefer1.map(f=>(f._2,(f._1,f._3))))
    //    (4,((2,0.3333333333333333),(3,1.0)))
    //    (4,((2,0.3333333333333333),(4,1.0)))
    //    (4,((2,0.3333333333333333),(6,1.0)))
    //    (2,((4,0.3333333333333333),(1,1.0)))
    //    (2,((4,0.3333333333333333),(4,1.0)))
    //    (2,((4,0.3333333333333333),(5,1.0)))
    //    (2,((3,0.4082482904638631),(1,1.0)))
    //    (2,((3,0.4082482904638631),(4,1.0)))
    //    (2,((3,0.4082482904638631),(5,1.0)))
    //    (2,((1,0.6666666666666666),(1,1.0)))
    //    (2,((1,0.6666666666666666),(4,1.0)))
    //    (2,((1,0.6666666666666666),(5,1.0)))
    //    (3,((2,0.4082482904638631),(2,1.0)))
    //    (3,((2,0.4082482904638631),(5,1.0)))
    //    (3,((1,0.8164965809277261),(2,1.0)))
    //    (3,((1,0.8164965809277261),(5,1.0)))
    //    (1,((2,0.6666666666666666),(1,1.0)))
    //    (1,((2,0.6666666666666666),(2,1.0)))
    //    (1,((2,0.6666666666666666),(5,1.0)))
    //    (1,((3,0.8164965809277261),(1,1.0)))
    //    (1,((3,0.8164965809277261),(2,1.0)))
    //    (1,((3,0.8164965809277261),(5,1.0)))

    //3.矩阵计算，i行与j列元素相乘
    val rdd_app1_R3=rdd_app1_R2.map(f=>((f._2._2._1,f._2._1._1),f._2._2._2 * f._2._1._2.toDouble))
    //    ((3,2),0.3333333333333333)
    //    ((4,2),0.3333333333333333)
    //    ((6,2),0.3333333333333333)
    //    ((1,4),0.3333333333333333)
    //    ((4,4),0.3333333333333333)
    //    ((5,4),0.3333333333333333)
    //    ((1,3),0.4082482904638631)
    //    ((4,3),0.4082482904638631)
    //    ((5,3),0.4082482904638631)
    //    ((1,1),0.6666666666666666)
    //    ((4,1),0.6666666666666666)
    //    ((5,1),0.6666666666666666)
    //    ((2,2),0.4082482904638631)
    //    ((5,2),0.4082482904638631)
    //    ((2,1),0.8164965809277261)
    //    ((5,1),0.8164965809277261)
    //    ((1,2),0.6666666666666666)
    //    ((2,2),0.6666666666666666)
    //    ((5,2),0.6666666666666666)
    //    ((1,3),0.8164965809277261)
    //    ((2,3),0.8164965809277261)
    //    ((5,3),0.8164965809277261)

    //4.用户:元素累加求和
    val rdd_app1_R4=rdd_app1_R3.reduceByKey((x,y)=>x+y)
    //    ((1,1),0.6666666666666666)
    //    ((1,4),0.3333333333333333)
    //    ((2,1),0.8164965809277261)
    //    ((6,2),0.3333333333333333)
    //    ((1,3),1.2247448713915892)
    //    ((4,3),0.4082482904638631)
    //    ((4,2),0.3333333333333333)
    //    ((5,3),1.2247448713915892)
    //    ((2,2),1.0749149571305296)
    //    ((4,4),0.3333333333333333)
    //    ((1,2),0.6666666666666666)
    //    ((2,3),0.8164965809277261)
    //    ((3,2),0.3333333333333333)
    //    ((4,1),0.6666666666666666)
    //    ((5,4),0.3333333333333333)
    //    ((5,1),1.4831632475943928)
    //    ((5,2),1.0749149571305296)

    //5.用户，对结果过滤已有的物品
    val rdd_app1_R5=rdd_app1_R4.leftOuterJoin(user_prefer1.map(f=>((f._1,f._2),1))).
      filter(f=>f._2._2.isEmpty).map(f=>(f._1._1,(f._1._2,f._2._1)))
    //    (1,(4,0.3333333333333333))
    //    (6,(2,0.3333333333333333))
    //    (1,(3,1.2247448713915892))
    //    (4,(3,0.4082482904638631))
    //    (2,(2,1.0749149571305296))
    //    (3,(2,0.3333333333333333))
    //    (4,(1,0.6666666666666666))
    //    (5,(4,0.3333333333333333))

    //对结果继续排序
    val rdd_app1_R6=rdd_app1_R5.groupByKey()
    val rdd_app1_R7=rdd_app1_R6.map(f=>{
      val i2=f._2.toBuffer
      val i2_2=i2.sortBy(_._2)
      if(i2_2.length>r_number){
        i2_2.remove(0,(i2_2.length-r_number))
      }
      (f._1,i2_2.toIterable)
    })
    //    (4,ArrayBuffer((3,0.4082482904638631), (1,0.6666666666666666)))
    //    (5,ArrayBuffer((4,0.3333333333333333)))
    //    (6,ArrayBuffer((2,0.3333333333333333)))
    //    (2,ArrayBuffer((2,1.0749149571305296)))
    //    (3,ArrayBuffer((2,0.3333333333333333)))
    //    (1,ArrayBuffer((4,0.3333333333333333), (3,1.2247448713915892)))

    //对结果继续排序
    val rdd_app1_R8=rdd_app1_R7.flatMap(f =>{
      val id2=f._2
      for(w<-id2) yield (f._1,w._1,w._2)
    })
    rdd_app1_R8.foreach(println)
    //    (4,3,0.4082482904638631)
    //    (4,1,0.6666666666666666)
    //    (5,4,0.3333333333333333)
    //    (6,2,0.3333333333333333)
    //    (2,2,1.0749149571305296)
    //    (3,2,0.3333333333333333)
    //    (1,4,0.3333333333333333)
    //    (1,3,1.2247448713915892)

    rdd_app1_R8.map(f=>UserRecomm(f._1,f._2,f._3))
  }

}
